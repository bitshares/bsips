    BSIP: 0061
    Title: Fix locked accounts with circular dependencies 
    Authors: OpenLedgerApp <https://github.com/OpenLedgerApp>
    Status: Draft
    Type: Protocol
    Created: 2019-22-02
    Updated: 
    Discussion: https://github.com/bitshares/bsips/issues/94
    Worker:


# Abstract
BitShares allow to change permissions of account A to account A. See *Cycles* paragraph of https://bitshares.org/technology/dynamic-account-permissions for details. More information can be found here: https://steemit.com/blockchain/@hipster/sad-story-how-i-lost-bitshares-account

# Motivation
We offer to develop additional functionality "Prevent to create cycled accounts". This functionality will avoid to create or update account authority with circular dependencies in the future.

# Rationale
According to our investigation, BitShares has about 384 locked accounts with circular dependencies. Most of these accounts are locked by mistake. 

# Specifications

## Prevent circular dependencies
We must extend create and update account evaluators adding code that detect cycled authorities and throws exception in do_evaluate() method if cycle detected.
To avoid any misunderstanding of existing authorization mechanism we propose to reuse actual code of sign_state::check_authority(). Make template class traverse_authorities_state and parametrize it with approve() method. By default approve = signed_by(), an existing method of sign_state class. We add keys_available() method to resolve signing path. So, check_authority() returns true, if signing path fully ends with existing keys.

## "Lock"-operation
"Lock"-operation is the last *account_create_operation* (or *account_update_operation*) that led the account to a locked state. No more operations possible on behalf of this account.

## Unlocking account
To unlock account we have to find previous *account_create_operation* (or *account_update_operation*) that changed owner or active authority. This operation will be reapplied to undo "lock"-operation if possible. See Discussion.

## Fix locked accounts
Firstly we need to find all locked accounts in first maintenance after hard-fork. Maybe locked accounts should be marked for unlock. Then fix them. There are two approaches here:

    1) Automatic (unconditional)
        - Find latest operation ("lock"-operation) among operations of cycled accounts. Do it for each cycle.
        - Undo all "lock"-operations. Find previous account update/create operation that changes authorities and redo it.

    2) Manual (on-demand). Unlocking can be performed only by the account that performed the operation that led to the blocking, using the credentials immediately prior to blocking. That is, not all the keys from the history of this account fit. Thus, you can unlock an account that has been blocked only by mistake and only if the necessary credentials are available. Here we will avoid illegal behavior.
        - New type of operation defined: unlock_account_operation { account_to_unlock : account_id_type }.
        - Initiator (potentially *account_to_unlock*) signs the transaction using its previous authority preceding the locked state.
        - Initiator (potentially *account_to_unlock*) pays fee for this operation.
        - *account_to_unlock* should have sufficient balances to perform this operation.
        - Check if *account_to_unlock* is locked in unlock_account_evaluator.
        - Check if *account_to_unlock* is authorized to perform the operation (transaction signed with previous authority).
        - Undo "lock"-operation. See Discussion-Unlocking account.

# Discussion
## Unlocking account
Operation that prior to locked state will be fully re-done. There is an option - only owner or active authorities can be restored.

## Maximum authority depth
Should we identify authority as locked in case of cycle only? Bitshares has *max_authority_depth* parameter. So, authorities with delegetion depth > *max_authority_depth* are potentially locked. Should we prevent this?

# Examples
## Unlocking account using previous authority. Fully re-done operation
There is following use case:
    1) Account "Alice" was created
    2) Account "Alice" was updated with new authorities and options (opts 1) - here: prior state
    3) Account "Alice" was updated with new options (opts 2)
    4) Account "Alice" was updated with new options (opts 3)
    5) Account "Alice" was updated with new authorities - here: locked state
To unlock "Alice" we need to reapply update operation at step 2. But latest account options (opts 3) at step 4 will be lost.

## Unable to unlock account
Use case:
    1) Account "Alice" delegates its authority to "Bob" - here: prior state
    2) Account "Charlie" delegates its authority to "Alice"
    3) Account "Alice" delegates its authority to "Charlie" (transaction was signed with Bob's private key) - here: locked state
    4) Account "Bob" delegates its authority to "Charlie" - here: locked state
To unlock "Alice" we need to reapply update operation at step 1. But "Bob" also locked, we have double lock here.

## Maximum authority depth exceeded
Account "Alice" has key authority. 
Account "Bob" delegates its authority to "Alice". 
Account "Charlie" delegates its authority to "Bob". 
Account "Dan" delegates its authority to "Charlie".
So, we have locked account "Dan". Transactions on behalf of "Dan" will always failed due to maximum depth limit until depth limit changed by committee. Current maximum depth limit in Bitshares = 2. (to be expanded)

# Summary for Shareholders

# Copyright
This document is placed in the public domain.

# See Also
https://github.com/bitshares/bitshares-core/issues/269